#!/usr/bin/env julia

include("util.jl")
include("ipmi.jl")
include("fan.jl")
include("cpu.jl")
include("disk.jl")

include("config.jl")

using Util
import Util: debug, trace

"""Scale a value from one range to another.

   For example, `scale(35, 30:60, 0:100)` can be used to determine the required fan speed
   for a sensor at 35 degrees, requesting 0% duty for 30 degrees and 100% for 60 degrees.
"""
function scale(value, from::UnitRange, to::UnitRange)
    from_range = from.stop - from.start
    to_range = to.stop - to.start
    value = clamp(value, from.start, from.stop)
    return to.start + (value-from.start) * to_range/from_range
end

"""Determine the required fan RPM to cool active disks."""
function disk_cooling(disks, active_disks)
    # if there's an active disk, always cool a little (to prevent cyclic behavior,
    # and just to be safe because the disk temperatures are cached for a minute)
    min_duty = isempty(active_disks) ? MIN_DUTY : MIN_ACTIVE_DUTY

    # check every drive's temperature
    temps = filter(temp->!isnan(temp), map(Disk.temp, disks))
    if isempty(temps)
        warn("Could not query temperature of ", join(disks, ", ", " or "))
        min_duty
    else
        maxtemp = maximum(temps)
        trace("Disks ", join(disks, ", ", " and "), " at $(maxtemp)°C")
        scale(maxtemp, 30:40, min_duty:100)
    end
end

"""Determine the required fan RPM to cool the CPU."""
function cpu_cooling()
    # the CPU doesn't really need cooling when it drops below 40 degrees
    # (especially because we re-check this value every some seconds,
    #  not every minute like with the `disk_cooling`)
    temp = CPU.temp()
    trace("CPU at $(temp)°C")
    scale(temp, 40:70, MIN_DUTY:100)
end

function main(args)
    ## init

    ccall(:geteuid, Cint, ()) == 0 || error("Run this script as root.")

    info("Checking fan limits")
    limits_changed = false
    data = IPMI.sensors()
    function check_limits!(fan, noncritical, critical, nonrecoverable)
        if data[fan].noncritical != noncritical ||
           data[fan].critical != critical ||
           data[fan].nonrecoverable != nonrecoverable
            IPMI.limits!(fan, noncritical, critical, nonrecoverable)
           return true
        end
        return false
    end
    # NOTE: RPM settings need to be divisible by 100, or they get rounded anyway
    # NOTE: MIN_DUTY should be chosen in terms of the lower bounds, ie. setting MIN_DUTY
    #       shouldn't make the RPM drop below any of the lower limits configured here
    ## Arctic F12 PWM CO
    for fan in ["FAN1", "FAN2", "FAN3", "FANA"]
        limits_changed |= check_limits!(fan, 200:1600, 200:1800, 100:2000)
    end
    ## boxed Intel cooler
    limits_changed |= check_limits!("FAN4", 700:3300, 600:3500, 500:3700)
    if limits_changed
        info("Limits have changed")
        sleep(5)
    end

    if Fan.mode() != Fan.full
        info("Enabling manual fan control")
        Fan.mode!(Fan.full)
        sleep(5)
    end

    info("Resolving disk names")
    Disk.resolve!(PERIPHERAL_DISKS)
    Disk.resolve!(SYSTEM_DISKS)


    ## main

    info("Starting disk usage monitor")
    disks = Set{String}(PERIPHERAL_DISKS ∪ SYSTEM_DISKS)
    @async Disk.monitor_usage()
    active_disks = Set(filter(device->Disk.power(device)==Disk.active, disks))

    info("Entering main loop")
    current_peripheral_duty = 0
    current_system_duty = 0
    while true
        # did any disk wake up?
        for device in setdiff(disks, active_disks)
            usage = Disk.usage(device)
            usage == nothing && continue

            if usage[1] > 0
                debug("Disk $device is now active")
                if Disk.power(device) != Disk.active
                    warn("Disk $device should be active, but isn't?")
                else
                    push!(active_disks, device)
                end
            end
        end

        # do we need to put any disk to sleep?
        for device in active_disks
            usage = Disk.usage(device)
            if usage[2] != nothing && usage[2] == 0     # idle for 5 minutes
                debug("Suspending disk $device")
                # NOTE: we put disks in standby, not sleep, because
                # - munin plugins (hddtemp, smartctl) wake the disk from sleep, but not standby
                # - waking the disks from sleep seems to fail sometimes:
                #     exception Emask 0x0 SAct 0x0 SErr 0x50000 action 0x6
                #     waking up from sleep
                #     SError: { PHYRdyChg CommWake }
                #   at which point the entire link gets reset...
                # if using SLEEP, also adjust the threshold for Disk.temp
                # (but note that the temperature for disks in SLEEP cannot be read!)
                Disk.power!(device, Disk.standby)
                delete!(active_disks, device)
            end
        end

        # control the peripheral fan
        let duty = disk_cooling(PERIPHERAL_DISKS, PERIPHERAL_DISKS ∩ active_disks)
            if current_peripheral_duty != duty
                debug("Setting peripheral fan to $(duty)%")
                Fan.duty!(Fan.peripheral, duty)
                current_peripheral_duty = duty
            end
        end

        # control the system fan
        let duty = max(disk_cooling(SYSTEM_DISKS, SYSTEM_DISKS ∩ active_disks), cpu_cooling())
            if current_system_duty != duty
                debug("Setting system fan to $(duty)%")
                Fan.duty!(Fan.system, duty)
                current_system_duty = duty
            end
        end

        sleep(5)
    end
end

try
    main(ARGS)
catch ex
    Fan.mode!(Fan.optimal)
    rethrow(ex)
end
